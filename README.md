# Intersection Observer 案例

## 启动服务端服务器

### 从项目根目录进入服务端目录

```sh
cd server
```

### 下载服务端依赖

```sh
go mod tidy
```

### 运行服务端服务器

```sh
go run .
```

## 启动客户端服务器

### 从项目根目录进入客户端目录

```sh
cd client
```

### 下载客户端依赖

```sh
pnpm install
```

### 运行客户端服务器

```sh
pnpm dev
```

## 关于交叉观察器（Intersection Observer）

### 提问 AI

这是一段官方说明，为什么元素的进入和退出就和普通的事件监听不一样？

> 交叉观察器 API 可令代码注册一个回调函数，当特定元素进入或退出与另一元素（或视口）的交集时，或者当两个元素之间的交集发生指定变化时，该函数就会被执行。这样，网站就不再需要在主线程上做任何事情来监视这种元素交集，浏览器也可以根据自己的需要优化交集管理。

### AI 回答

元素的进入和退出与普通的事件监听有所不同，主要因为 **Intersection Observer API** 的设计和目的与传统事件监听机制在实现方式和优化目标上有所不同。

#### 1. **工作机制的差异**

- **普通事件监听**：传统的事件监听机制依赖于不断轮询或者绑定特定的事件（如滚动、鼠标移动等）来监视元素是否进入视口。例如，在监视一个元素何时进入视口时，你可能会在滚动事件上绑定监听器，每次页面滚动时手动检查元素的位置。这种方法的缺点是：滚动事件触发频率高，会不断检查位置，导致性能问题，尤其在页面上有多个需要监控的元素时，开销会变得非常大。

- **Intersection Observer API**：这是一个异步回调机制，浏览器会在合适的时机调用回调函数（比如当页面渲染引擎已经计算好了元素和视口的交集变化时）。相比于滚动事件，它由浏览器内部优化，并且不会在每次滚动时强制调用。浏览器会批量处理多个元素的交集变化，并在后台合并、优化操作，从而减少了对主线程的影响。

#### 2. **性能优化**

- **普通事件监听器的性能问题**：对于像滚动这样的高频事件，每次触发时，都会进行计算和 DOM 操作，频繁的检查导致性能下降，尤其是在复杂的页面中，可能出现卡顿。

- **Intersection Observer 的性能优势**：它由浏览器引擎处理，只有当元素的可见性或交集发生变化时才会调用回调函数。浏览器能更智能地调度这些任务，使得页面性能更好，并减少主线程的负担。这是因为浏览器可以利用 GPU 以及异步计算，优化了交集的计算过程，不需要频繁轮询和触发回调。

#### 3. **异步回调与同步事件的区别**

- **普通事件监听器通常是同步的**：例如，当你监听滚动事件时，滚动一发生，浏览器会立即触发相应的回调函数。如果滚动频繁，回调函数也会频繁触发。

- **Intersection Observer 是异步的**：它不会立即触发，而是浏览器会根据优化策略在合适的时机（如下一帧渲染之前）执行回调，这样可以减轻主线程的压力。此外，由于 Intersection Observer 是异步的，它的行为不会影响到页面的其他交互或渲染操作，确保了流畅性。

#### 4. **可调节的阈值**

- **Intersection Observer 提供了阈值选项**：你可以定义在元素进入多少比例的可视区域后触发回调（例如 50% 可见时触发，而不是一进入就触发）。这种灵活性和优化在普通事件监听器中是难以实现的，通常需要手动编写复杂的逻辑来处理。

#### 5. **减少手动计算和冗余操作**

- **普通事件监听**：你需要在监听滚动、窗口大小变化等事件时手动计算元素的位置和大小，并手动判断是否进入了视口。
- **Intersection Observer**：浏览器帮你自动完成了这些计算，并且只在真正的交集变化时触发回调，减少了不必要的计算。

#### 总结

**Intersection Observer API** 是为了性能优化而设计的，它使得开发者能够高效地检测元素的可见性或交集变化，而不用依赖传统的高频事件监听和手动计算。这种异步、优化的机制不仅减少了浏览器主线程的负担，还能提升页面的流畅性，特别是在涉及懒加载图片、广告曝光检测等场景时具有显著的优势。
